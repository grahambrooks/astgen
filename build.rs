use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;

fn main() {
    let git_sha = Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .output()
        .expect("Failed to execute git command")
        .stdout;

    let git_sha = String::from_utf8_lossy(&git_sha).trim().to_string();

    let out_dir = env::var("OUT_DIR").unwrap();
    let version_file = format!("{}/version.txt", out_dir);

    std::fs::write(&version_file, git_sha).expect("Failed to write version file");

    println!("cargo:rustc-env=VERSION_FILE={}", version_file);

    // Extract tree-sitter dependency versions from Cargo.toml
    generate_version_file(&out_dir);

    // Make the build script rerun if Cargo.toml changes
    println!("cargo:rerun-if-changed=Cargo.toml");
}

fn generate_version_file(out_dir: &str) {
    let cargo_toml = std::fs::read_to_string("Cargo.toml").expect("Failed to read Cargo.toml");

    let mut versions: Vec<(String, String)> = Vec::new();

    for line in cargo_toml.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("tree-sitter-") {
            if let Some((name_part, rest)) = trimmed.split_once('=') {
                let name = name_part.trim();
                // Handle simple version specification "x.y.z" or inline table
                let value = rest.trim();
                if value.starts_with('"') {
                    if let Some(end_quote) = value[1..].find('"') {
                        let ver = &value[1..1 + end_quote];
                        versions.push((name.to_string(), ver.to_string()));
                    }
                } else if value.starts_with('{') {
                    // Find version = "..." inside inline table
                    if let Some(vpos) = value.find("version") {
                        let after = &value[vpos..];
                        if let Some(eq_pos) = after.find('=') {
                            let after_eq = after[eq_pos + 1..].trim();
                            if after_eq.starts_with('"') {
                                if let Some(end_quote) = after_eq[1..].find('"') {
                                    let ver = &after_eq[1..1 + end_quote];
                                    versions.push((name.to_string(), ver.to_string()));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    versions.sort_by(|a, b| a.0.cmp(&b.0));

    let mut code = String::from("// Auto-generated file - DO NOT EDIT\n// Generated by build.rs based on Cargo.toml tree-sitter dependencies\n\n");

    for (name, version) in &versions {
        let const_name = name.replace('-', "_").to_uppercase();
        code.push_str(&format!("pub const {}_VERSION: &str = \"{}\";\n", const_name, version));
    }

    code.push_str("\n/// All discovered tree-sitter parser versions (name, version)\n");
    code.push_str("pub const TREE_SITTER_PARSERS: &[(&str, &str)] = &[\n");
    for (name, version) in &versions {
        code.push_str(&format!("    (\"{}\", \"{}\"),\n", name, version));
    }
    code.push_str("];\n");

    let dest_path = Path::new(out_dir).join("versions_gen.rs");
    let mut file = File::create(dest_path).expect("Failed to create versions_gen.rs");
    file.write_all(code.as_bytes())
        .expect("Failed to write versions_gen.rs");
}
